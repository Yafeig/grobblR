---
title: "grobblR Vignette"
author: "Calvin Floyd"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{grobblR Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

Being an avid user of R, I attempt to avoid using Microsoft Excel at any cost. When I first started using R however, I found Excel to be much better at one thing in particular: Creating extremely customizable PDF reports. In Excel you can shade specific cells, adjust font sizes, pick borders and many other things to create unique-looking reports, which are able to be fitted onto a single sheet of paper. While Excel is very good at being flexible and letting the user customize the look of the report, the process is very manual and it definitely is not as well-equipped at data analysis as R. Working for the Sacramento Kings, we needed to create various reports on a daily basis and we were not about to do our data analysis in R, transfer the data into Excel, and then format the report to how we wanted it to look. We needed to come up with a way to create automated, flexible PDF reports within the R environment for our front office and coaching staff. The `grobblR` package is an extenstion of the methodology we implemented to create those reports - using grid graphical objects, AKA *grobs*, seen in the `grid` and `gridExtra` packages. We believe that the `grobblR` package is one of the better options to create unique, flexible reports within R - and helps users stay away from Excel!

## What is a grob?

Taken from the `grid::grob()` [documentation](https://stat.ethz.ch/R-manual/R-devel/library/grid/html/grid.grob.html):

> A grid graphical object (“grob”) is a description of a graphical item. These basic classes provide default behaviour for validating, drawing, and modifying graphical objects. 

Within `grobblR`, the main grob's allowed are:
* data frames / matrices
* ggplots
* `.png` files
* character strings

It was our goal with this package to create flexible functionality that would allow the user to combine these grob's in any way they wanted to.

## Grob Layout

When coming up with what the `grobblR` package would look like, we first had to decide on the most intuitive way to layout your grob's on the page. We decided on a Shiny-like bootstrap method, which would combine grob-row's (a row combining one or several grobs) and grob-column's (a column combining one or several grobs) within an overall grob-layout. What the `grob_layout()` function does is evaluate the overall dimensions of the page you desire, and then distributes heights and widths to the grobs that will make up the page, based on proportions and the amount of grob-rows (`grob_row()`) and grob-columns (`grob_col()`) within the overall `grob_layout()`. For example, if we wanted to do a simple 2x2 grid system on a 100 mm x 100 mm page, we would simply write:

```{r 2x2 system}

grob <- grob_layout(
  grob_row(grob_col('1'), grob_col('2')),
  grob_row(grob_col('3'), grob_col('4')),
  height = 100,
  width = 100)

gridExtra::grid.arrange(grob)

```

The `grob_row()`'s tell the `grob_layout()` that we want two rows on the outer-most layer, and since there are two `grob_col()`'s within each of the `grob_row()`'s, the result is a 2x2 grid. But the result doesn't have to be a nice 2x2 grid - we could have a layout where the first row has two columns and the second has one:

```{r 2 row, 3 element system}

grob <- grob_layout(
  grob_row(grob_col('1'), grob_col('2')),
  grob_row(grob_col('3')),
  height = 100,
  width = 100)

gridExtra::grid.arrange(grob)

```


In order to see exactly how the grobs are laid out, let's add borders to each of the grob-rows and grob-cols:

```{r 2x2 system w/ borders}

grob <- grob_layout(
  grob_row(border = T, grob_col('1', border = T), grob_col('2', border = T)),
  grob_row(border = T, grob_col('3', border = T), grob_col('4', border = T)),
  height = 100,
  width = 100)

gridExtra::grid.arrange(grob)

```




Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
