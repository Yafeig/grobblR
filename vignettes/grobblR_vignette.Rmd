---
title: "grobblR Vignette"
author: "Calvin Floyd"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{grobblR Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 4,
  fig.height = 4
)
```

## Introduction

Being an avid user of R, I attempt to do everything I need to do within R and avoid using applications such as Microsoft Excel. When I first started using R, however, I found Excel to be noticeably better at one thing in particular: Creating extremely customizable PDF reports. In Excel you can shade specific cells, adjust font sizes, pick borders and many other things to create unique-looking reports, which are able to be fitted onto a single sheet of paper. While Excel is very good at being flexible and letting the user customize the look of the report, the process is rather manual and forces a user like myself to go outside the R workspace to another application.

Working for the Sacramento Kings in their analytics department, we needed to create various reports on a daily basis and we were not about to do our data analysis in R, transfer the data into Excel, and then format the report to how we wanted it to look. We needed to come up with a way to create automated, flexible multi-page PDF reports within the R environment for our front office and our coaching staff. The `grobblR` package is an extenstion of the methodology we implemented to create those reports - using "grid graphical objects", AKA *grobs*, seen in the `grid` and `gridExtra` packages. We believe that the `grobblR` package is one of the better options to create unique, flexible reports within R - and helps users stay away from the dreaded Excel!

```{r Install grobblR}
# devtools::install_github('calvinmfloyd/grobblR')
library(grobblR)
```

***

## What is a grob?

Taken from the `grid::grob()` [documentation](https://stat.ethz.ch/R-manual/R-devel/library/grid/html/grid.grob.html):

> A grid graphical object (“grob”) is a description of a graphical item. These basic classes provide default behaviour for validating, drawing, and modifying graphical objects. 

Within `grobblR`, the objects able to be converted to a grob are:  

  * Data frames / matrice  
      + A Vector of values
  * `ggplot` plots  
  * `.png` files  
  * Character strings  
  * Empty space (represented with `NA`)  

It was our goal with this package to create flexible functionality that would allow the user to combine these types of grobs in any way they desired.

***

## Grob Layout

When coming up with what the `grobblR` package would look like, we first had to decide on the most intuitive way to layout the user's grobs on the page. We decided on a Shiny-like bootstrap method, which would incorporate nested grob-rows (a row combining one or several grobs) and grob-columns (a column combining one or several grobs) within an overall layout of grobs (which we will call a grob-layout). What the `grob_layout()` function does is evaluate the overall dimensions of the page you desire, and then distributes heights and widths to the grobs that will make up the page, based on proportions and the amount of grob-rows (`grob_row()`) and grob-columns (`grob_col()`) within the overall grob-layout (`grob_layout()`). For example, if we wanted to do a simple 2x2 grid system on a 100 mm x 100 mm page, we would simply write:

```{r 2x2 system}
gl <- grob_layout(
  grob_row(grob_col(1), grob_col(2)),
  grob_row(grob_col(3), grob_col(4)),
  height = 100,
  width = 100,
  padding = 5
  )

gridExtra::grid.arrange(gl$grob)
```

The `grob_row()`'s tell the `grob_layout()` that we want two rows on the outermost layer, and since there are two `grob_col()`'s within each of the `grob_row()`'s, the result is a 2x2 grid. But the result doesn't have to be a nice 2x2 grid - we could have a layout where the first row has two columns and the second has one:

```{r 2 row, 3 element system}
gl <- grob_layout(
  grob_row(grob_col(1), grob_col(2)),
  grob_row(grob_col(3)),
  height = 100,
  width = 100,
  padding = 5
  )

gridExtra::grid.arrange(gl$grob)
```

Similar to the objects outputted by `grob_layout()`, the objects outputted by `grob_row()` and `grob_col()` also can produce their own grobs. Not as clean as performing the actions through `grob_layout()`, but the height and width can also be tweaked for these grob-column and grob-row objects - where the default for both is 100mm x 100mm (setting `border = T` will be addressed later on).

```{r grob_col grob}
gl <- grob_col('grob-column grob')
gl$height <- 50
gl$width <- 50
gridExtra::grid.arrange(gl$grob)
```

```{r grob_row grob}
gl <- grob_row(
  grob_col('grob-column 1', border = T),
  grob_col('grob-column 2', border = T)
  )
gl$height <- 50
gl$width <- 100
gridExtra::grid.arrange(gl$grob)
```

Another feature of `grobblR` is that the outermost `grob_row()` objects can either be loose within `grob_layout()` or they can be contained within a list:

```{r list, loose demonstration}
# gl <- grob_layout(
#   grob_row(grob_col(1), grob_col(2)),
#   grob_row(grob_col(3)),
#   height = 100,
#   width = 100,
#   padding = 5,
#   grob_padding = 2)

# OR

gl <- grob_layout(
  list(
    grob_row(grob_col(1), grob_col(2)),
    grob_row(grob_col(3))
  ),
  height = 100,
  width = 100,
  padding = 5
  )

gridExtra::grid.arrange(gl$grob)
```

One benefit of this is in case the user isn't totally sure how many grob-rows there will be within the grob-layout, the user can dynamically create the list of grob-rows and insert that list within `grob_layout()`:

```{r list, loose demonstration}

list_of_grob_rows <- list()
for(i in 1:4){
  list_of_grob_rows[[i]] <- grob_row(grob_col(i), grob_col(i^2), border = T)
}

gl <- grob_layout(
  list_of_grob_rows,
  height = 100,
  width = 100,
  padding = 5
  )

gridExtra::grid.arrange(gl$grob)
```

The same utility can also be found with the `grob_row()` function:

```{r list, loose demonstration (grob-row)}

list_of_grob_cols <- list()
for(i in 1:4){
  list_of_grob_cols[[i]] <- grob_col(i, border = T)
}

gl <- grob_layout(
  grob_row(list_of_grob_cols),
  height = 100,
  width = 100,
  padding = 5
  )

gridExtra::grid.arrange(gl$grob)
```

### Nested Rows and Columns

One of the ways that makes `grobblR` truly flexible is the ability to create "nested" rows and columns - where we can insert grob-rows into grob-columns, and vice-versa. This is made possible by incorporating the `R6` package's active classes. Say we wanted to edit the above grob and add a second grob-column in the second grob-row which contains two grob-rows within it, we would write (setting `border = T` for each of the grob-rows and grob-columns to see how space is allocated):

```{r 2x2 system w/ borders}
gl <- grob_layout(
  grob_row(
    grob_col(1, border = T),
    grob_col(2, border = T),
    border = T),
  grob_row(
    grob_col(3, border = T),
    grob_col(
      grob_row(grob_col(4, border = T), border = T),
      grob_row(grob_col(5, border = T), border = T),
      border = T),
    border = T),
  height = 100,
  width = 100,
  padding = 5)

gridExtra::grid.arrange(gl$grob)
```

Note that `grob_col()` is where the object of the user's choosing is actually converted to a grob, and each `grob_col()` needs to be wrapped in a `grob_row()`, in order for the flow of information to work correctly. Thus, the outermost layer in a grob-layout must consist of grob-rows, each of which have one or several grob-columns inside.

### Padding

The `padding` parameter within `grob_layout()` controls the very outside padding on the page (default of 10 mm), and the `padding` parameter within `grob_col()` controls the amount of room between the grob itself and the outer grob-row (default of 2 mm) - helping separate the grobs and giving them air to breathe. The `padding` parameter within `grob_col()` allows grob-columns to be shifted around its allotted space, making use of the `hjust` and `vjust` parameters within `grob_col()`. The defaults for both are `0.5` (having the grob centered in its allotted space). Setting `hjust` to `1.0` pushes the grob as far right as it can go (opposite for setting it to `0.0`), and setting `vjust` to `1.0` pushes the grob as far to the top as it can go (again, opposite for setting it to `0.0`):

```{r hjust and vjust}
gl <- grob_layout(
  grob_row(
    # center
    grob_col(1, border = T, padding = 5),
    # top center
    grob_col(2, border = T, padding = 5, vjust = 1)),
  grob_row(
    # top right
    grob_col(3, border = T, padding = 5, hjust = 1, vjust = 1),
    # bottom left
    grob_col(4, border = T, padding = 5, hjust = 0, vjust = 0)),
  height = 100,
  width = 100,
  padding = 5)

gridExtra::grid.arrange(gl$grob)
```

### Size Control - Proportion Paramter

In order to control the height and the width of the size of these grids, the user must tweak the `p` parameter within both `grob_row()` and `grob_col()`. The default for `p` is 1, but let's see what happens when we tweak it for a grid-system with two grob-rows:

```{r 2x1 system - p parameter}
gl <- grob_layout(
  grob_row(grob_col('p=2'), p = 2, border = T),
  grob_row(grob_col('p=1'), p = 1, border = T),
  height = 100,
  width = 100,
  padding = 5)

gridExtra::grid.arrange(gl$grob)
```

There are two grob-rows on the same, outermost layer of the grob-layout, so the height of the page, 90 mm (removing 10 mm for padding), will be distributed between those two grob-rows. The `p` parameter (standing for "proportion"), controls how the height is proportionally distributed. Since the first grob-row has a `p` of 2, and the second has a `p` of 1, the first grob-row gets `2/(2+1) = 2/3` of the height (60 mm), and the second grob-row gets `1/(2+1) = 1/3` of the height (30 mm). The same logic applies to grob-columns:

```{r 1x2 system - p parameter}
gl <- grob_layout(
  grob_row(
    grob_col('p=2', p = 2, border = T),
    grob_col('p=1', p = 1, border = T)
    ),
  height = 100,
  width = 100,
  padding = 5)

gridExtra::grid.arrange(gl$grob)
```

Since these are grob-columns and not grob-rows, the width, and not the height, of the allotted space is distributed among the two grob-columns. The same logic applies as the user goes deeper and deeper into the nested grob-rows and grob-columns - allotted space is equally distributed among grob-rows or grob-columns on the same level/layer unless the user specifies differently with `p`. It should be noted that `p` can be any positive numeric value, integer or not.

***

## General Aesthetics

### Grob Aesthetic Control - `ga_list`

In the `grobblR` package, there are many aspects the user can control the aesthetics of: Borders with the `border_aes_list` parameter, titles with the `title_aes_list` parameter, and aesthetics within the grobs themselves with the `aes_list` parameter. The user can only utilize these aesthetic paramters by using the `ga_list()` function, which has a wide variety of aesthetic options accepted by `grobblR` (such as `text_color` and `border_width`). Another pro of the function is that the user can easily see which aesthetic tweaks are allowed by going through the parameters of `ga_list()`. Examples of how `ga_list()` is implemented can be seen below in succeeding sections.

### Borders

As we just saw, setting `border = T` in either `grob_row()` or `grob_col()` puts a border around the respective grob-row or grob-column. Those borders can be customized with the `border_aes_list` parameter:

```{r Border customization}
gl <- grob_layout(
  grob_row(
    grob_col(
      'A',
      border = T,
      border_aes_list = ga_list(
        border_sides = 'right, bottom',
        border_color = 'red'
        )
      ),
    grob_col(NA, p = 0.25),
    grob_col(
      'B',
      border = T,
      border_aes_list = ga_list(border_width = 8)
      )
    ),
  grob_row(
    grob_col(
      'C',
      border = T,
      border_aes_list = ga_list(border_sides = 'top, bottom')
      ),
    grob_col(NA, p = 0.25),
    grob_col(
      'D',
      border = T,
      border_aes_list = ga_list(
        border_sides = 'left, right, bottom',
        border_color = 'blue',
        border_width = 5
        )
      )
    ),
  height = 100,
  width = 100,
  padding = 5)

gridExtra::grid.arrange(gl$grob)
```

The `border_aes_list` controls the aesthetics of the border. The three aesthetic controls for `border_aes_list` are `border_color`, which controls the color of the lines, `border_width`, which controls the thickness of the lines, and `border_sides`. As you can guess, `border_sides` within `ga_list()` controls which of the four borders show up around the grob-row or grob-column. Setting `border_sides` equal to "left, right" will show only the left and right borders and gets rid of the top and bottom ones. The default is "top, bottom, left, right", which gives all four sides of the border. Of course, these border aesthetics will only show up if `border = T`.

### Titles

Another general aesthetic of a grob-layout are title options for each grob-row, grob-column or the overall grob-layout itself:

```{r Title customization}
gl <- grob_layout(
  grob_row(
    grob_col('A'),
    grob_col(
      'B',
      title = 'grob-column Title',
      title_p = 0.5
      )
    ),
  grob_row(
    grob_col('C'),
    grob_col('D'),
    title = 'grob-row Title',
    title_p = 0.2,
    title_aes_list = ga_list(
      background_color = 'gray95',
      text_color = 'navy',
      font_face = 3
      )
    ),
  title = 'grob-layout Title',
  title_aes_list = ga_list(background_color = 'red'),
  height = 100,
  width = 100,
  padding = 5)

gridExtra::grid.arrange(gl$grob)
```

If a `title` is inputted into any of `grob_col()`, `grob_row()` or `grob_layout()`, a title will appear at the top of the respective allotted space. The default is the title taking up 10% (`title_p = 0.1`) of the allotted height (the title can take up a maximum of 50%), and a `gray40` color background with white font. The `title_aes_list` parameter controls the aesthetics of the title grob. The title grob is treated as a single value 1x1 matrix, so the aesthetic parameters in `title_aes_list` are treated the same as described in the Matrix Grobs section later on. 

### Page Number

Also, there is the option to add a `page_number` to the bottom right corner of your grob-layout within the `padding` space of the page:

```{r Page number example}
gl <- grob_layout(
  grob_row(grob_col('A'), grob_col('B')),
  grob_row(grob_col('C'), grob_col('D')),
  height = 100,
  width = 100,
  padding = 10,
  page_number = 1
  )

gridExtra::grid.arrange(gl$grob)
```

This will also come into play when we discuss the `grob_to_pdf()` function later on, and converting multiple grob-layouts into a multiple-page PDF report.

***

## Matrix Grobs

Data frames/matrices are probably the most complex of all the grobbable (yep, that's a word now) objects in the `grobblR` package. With matrices, each element is essentially its own tiny grob. So if the user has a `2x2` matrix which he/she wants to convert to a grob, the `grobblR` method is to create 4 distinct tiny grobs and combine them all together to create the appearance of the matrix which was inputted. This allows for very customizable looks for matrices - which we needed to do a lot in Sacramento. If we needed to color specific elements of the matrix, or change their font face, or change their font size, we could do that using this methodology. 

### Matrix Aesthetic Control

Using the `aes_list` parameter and the `ga_list()` function within `grob_col()`, the aesthetics of individual grobs can be adjusted to how the user intends them to appear. See `?grobblR::ga_list` for a full list and description for each of the possible aesthetic options.

### Cell-by-Cell Aesthetic Control

There's a lot to digest above, but these flexible aesthetics make for an incrediblly customizable matrix look. Say the user was only concerned with the background color of a matrix, and he/she wanted to have it uniform for every cell, all the user would need to do is set a single value for `bg_color` as an element within `aes_list`:

```{r Setting mat}
mat <- matrix(1:4, nrow = 2, byrow = T)
mat
```

```{r First matrix example}
gl <- grob_layout(
  grob_row(grob_col(mat, aes_list = ga_list(background_color = 'gray80'))),
  height = 100,
  width = 100
  )

gridExtra::grid.arrange(gl$grob)
```

But say the user wanted different cells of the matrix to have different background colors. He/she would need to specify a separate aesthetic matrix correpsonding to the background color of each cell of the original matrix. Since `mat` is a 2x2 matrix, we need to specify a another 2x2 matrix with each element denoting a background color for each of the cells in `mat`:

```{r Setting color_mat}
color_mat <- matrix(c('white', 'red', 'gray90', 'blue'), nrow = 2, byrow = T)
color_mat
```

```{r First matrix, cell-by-cell customization, 1}
gl <- grob_layout(
  grob_row(grob_col(mat, aes_list = ga_list(background_color = color_mat))),
  height = 100,
  width = 100
  )

gridExtra::grid.arrange(gl$grob)
```

The same can be said for most of the other aesthetic elements listed above. For example, the `text_color` can be changed for individual elements of a matrix, but `color_gradient_binary` is a `TRUE`/`FALSE` value, and cannot be changed for individual elements. Below is a grob-layout with 4 matrix grobs with various aesthetic elements tweaked.

```{r First matrix, cell-by-cell customization, 2}
mat_char <- matrix(c('Apple','Pear','Grape','Cherry'), nrow = 2, byrow = T)

gl <- grob_layout(
  grob_row(
    grob_col(
      mat,
      aes_list = ga_list(
        text_color = 'gray40',
        background_color = color_mat,
        font_face = 1
        )
      ),
    grob_col(
      mat_char,
      aes_list = ga_list(
        text_color = 'purple',
        background_color = 'gray90',
        border_sides = 'top, bottom',
        border_width = 2,
        text_just = 'left'
        )
      )
    ),
  grob_row(
    grob_col(
      mat,
      aes_list = ga_list(
        text_color = 'gray40',
        background_color = color_mat,
        border_sides = 'top, bottom, left, right',
        font_face = 4
        )
      ),
    grob_col(
      mat_char,
      aes_list = ga_list(
        text_color = color_mat,
        background_color = 'purple',
        text_just = 'right',
        text_v_just = 'top',
        font_face = 2
        )
      )
    ),
  height = 100,
  width = 100
  )

gridExtra::grid.arrange(gl$grob)
```

Definitely not the most appealing to the eye, but the flexibility of matrix grobs in `grobblR` is demonstrated.

### Color Gradients

Another feature I wanted to incorporate after seeing its usefulness in Excel, was the ability to color code column numeric values based on their value - where, for example, the low value would be colored red and the high value would be colored green, with a gradual color ascent going from red to green with yellow as a middle color. I also wanted to make it as flexible as possible, so the user could pick what colors he/she wants to use, and whether the color gradient would be binary or not (`color_gradient_binary`).

```{r Color Gradient Demonstration}
df <- data.frame(letter = letters[1:5], rank = 1:5, rank_2 = 5:1)

gl <- grob_layout(
  grob_row(
    grob_col(
      df,
      aes_list = ga_list(color_gradient_columns = 3)
      ),
    grob_col(
      df,
      aes_list = ga_list(
        color_gradient_columns = 3,
        color_gradient_binary = T,
        color_binary_cut_off = 2.5
        )
      )
    ),
  grob_row(
    grob_col(
      df,
      aes_list = ga_list(
        color_gradient_columns = c(2,3),
        color_gradient_max = 'blue',
        color_gradient_mid = 'purple',
        color_gradient_min = 'red'
        )
      ),
    grob_col(
      df,
      aes_list = ga_list(
        color_gradient_columns = c(2,3),
        color_gradient_binary = T,
        color_binary_cut_off = 2,
        color_binary_high = 'yellow',
        color_binary_equal = 'green',
        color_binary_low = 'blue'
        )
      )
    ),
  height = 100,
  width = 100
  )

gridExtra::grid.arrange(gl$grob)
```

### Column Name Treatment

Notice that the default look of the matrix/data frame changes once column names are added. When column names are detected on a matrix or data frame, the default look changes to make it look more like a table, rather than just individual elements of a matrix. When column names are included, it should be noted that the column names and the elements of the table itself are treated separately. If the user wants to edit elements of the column names instead of the table, then the user must insert a `colname_` in front of whatever aesthetic the user wants to change. For example, if the user wanted to change the text color of the column names to red, he/she would insert `colname_text_color = 'red'` into the `aes_list` list. This goes for any of the other aesthetics the user wants to change. The column header portion is treated as a `1 x m` matrix, where `m` is the number of columns of the matrix/data frame. Also, it should be noted that, at this moment in time, row names are ignored in `grobblR`.

```{r Column name edits}
gl <- grob_layout(
  grob_row(
    grob_col(df),
    grob_col(
      df,
      aes_list = ga_list(colname_text_color = 'red', text_color = 'blue')
      )
    ),
  grob_row(
    grob_col(
      df,
      aes_list = ga_list(colname_font_face = 3, font_face = 2)
      ),
    grob_col(
      df,
      aes_list = ga_list(
        colname_text_color = c('red','purple','blue'),
        colname_background_color = 'gray90',
        background_color = 'white'
        )
      )
    ),
  height = 100,
  width = 100
  )

gridExtra::grid.arrange(gl$grob)
```

### Vector of Values

Vectors of values in `grobblR` are treated as `1 x n` matrices (where `n` is the length of the vector). If the elements of the vector are named then those names are converted to column names, and treated as they usually are:

```{r Column name edits - Vector}
plain_vector <- c(1, 2, 3)
named_vector <- c('a' = 4, 'b' = 5, 'c' = 6)

gl <- grob_layout(
  grob_row(grob_col(plain_vector), border = T),
  grob_row(grob_col(named_vector), border = T),
  height = 100,
  width = 100
  )

gridExtra::grid.arrange(gl$grob)
```

***

## ggplot Grobs

The next objects accepted by `grobblR` are `ggplot2` plots. The `ggplot` plot is stretched or squished depending on what the dimensions of the allotted space are:

```{r ggplot Grobs}
data(iris)
library(ggplot2)
gg1 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  ggplot2::geom_point() +
  ggplot2::guides(color = F)

gg2 <- ggplot(iris, aes(x = Sepal.Length, y = Petal.Length, color = Species)) +
  ggplot2::geom_point() +
  ggplot2::guides(color = F)

gl <- grob_layout(
  grob_row(grob_col(gg1), grob_col(gg2)),
  grob_row(grob_col(head(iris))),
  title = 'Iris Dataset',
  height = 100,
  width = 100
  )

gridExtra::grid.arrange(gl$grob)
```

***

## Image Grobs

At this moment in time, only images in `.png` format are allowed in `grobblR`. In order for `grobblR` to detect the user wants to include an image, `.png` must be in the file name of the image. If the user does not want to maintain the aspect ratio of the image and allow it to be stretched within its allotted space, `maintain_aspect_ratio = F` must be inserted within the `aes_list` list.

```{r .png Grobs}
gl <- grob_layout(
  grob_row(
    grob_col('kings_logo.png', border = T),
    grob_col(
      'kings_logo.png',
      aes_list = ga_list(maintain_aspect_ratio = F),
      border = T
      ),
    border = T
    ),
  height = 100,
  width = 100
  )

gridExtra::grid.arrange(gl$grob)
```

***

## Character String Grobs

Also in Sacramento, we would need to include paragraphs of scouting reports for individual players on our PDF reports, so we needed to figure out a way to include long text into our grobs. `grobblR` handles long character strings by making the text as big as possible, while still being able to fit the text inside its allotted space. This results in automatically putting different words on different lines:

```{r simple text grob}
text <- "The quick brown fox jumps over the lazy dog."

gl <- grob_layout(
  grob_row(grob_col(text, border = T), border = T),
  height = 100,
  width = 100
  )

gridExtra::grid.arrange(gl$grob)
```

There are a couple things unique to character strings that the user can tweak in `aes_list` and `ga_list()`:  

  * `n_lines` - The maximum number of lines desired for the character string to be broken up into.
      + Useful for when only one line is desired (`n_lines = 1`).
  * `sep` - The separator within the character string which designates where a new line should start.
      + Useful for breaking up character strings meant to be bulleted lists.
  
In action:

```{r multi text grob layout}
bulleted_list <- paste0(
  "PG - Mike Bibby\n",
  "SG - Doug Christie\n",
  "SF - Peja Stojakovic\n",
  "PF - Chris Webber\n",
  "C - Vlade Divac")

gl <- grob_layout(
  grob_row(grob_col(text, border = T),border = T),
  grob_row(
    p = 2/3,
    border = T,
    grob_col(text, aes_list = ga_list(n_lines = 1, text_just = 'right'), border = T)
    ),
  grob_row(
    border = T,
    grob_col(
      bulleted_list,
      aes_list = ga_list(
        sep = '\n',
        text_just = 'left',
        text_color = 'purple',
        font_face = matrix(c(1,1,1,1,1), ncol = 1)
        )
      )
    ),
  height = 100,
  width = 100
  )

gridExtra::grid.arrange(gl$grob)
```

At the very end of the character string being processed, if the string is converted to `n` lines, the character string is converted into a `n x 1` matrix, so any aesthetic that can be changed with a matrix can also be applied here. Thus, you can edit separate lines' aesthetics with an `n x 1` aesthetic matrix (such as the matrix used in the `font_face` aesthetic for the bottom grob above), but the **user must make sure he/she is certain how many lines the character string is going to be converted to, or else the aesthetic change will not take**. Above `text_just` was implemented to right-align and left-align separate text grobs, and `text_color` was used to color the text. 

***

## Empty Space Grobs

Us here at the `grobblR` HQ understand that sometimes the user will need to bump some things to the top, to the bottom, to the left, or to the right. Sometimes the user might even need to compact some grobs - the automatic sizing occurring in `grobblR` only knows to fill allotted space with whatever object its given, so the grobs may appear stretched at times. After much deliberation, we decided on adding in the option to add *empty space grobs* with `NA` which are simply that: empty space. We saw this briefly in the secition discussing borders, but here is another example:

```{r empty space grob}
gl <- grob_layout(
  grob_row(
    border = T,
    grob_col(df, padding = 0),
    grob_col(
      padding = 0,
      grob_row(grob_col(df, padding = 0), padding = 0),
      grob_row(grob_col(NA, padding = 0), padding = 0)
      ),
    grob_col(
      padding = 0,
      grob_row(grob_col(NA, p = 1/3, padding = 0), padding = 0),
      grob_row(grob_col(df, padding = 0), padding = 0)
      )
    ),
  height = 100,
  width = 100
  )

gridExtra::grid.arrange(gl$grob)
```

The table on the left may appeared somewhat stretched because it's filling its allotted space, but the other two tables appear more properly sized thanks to the empty space grobs.

***

## Grob Layout to PDF

It should be noted that the default values for the `height` and `width` parameters within `grob_layout()` are `280` and `216`, as these are the values needed to properly fit the grob-layout onto a piece of `11 x 8.5` inch computer paper, portrait orientation. Thus, the defaults in `grob_layout()` are meant for printing and fitting the PDF of the grob-layout onto a piece of paper. Obviously there are other uses for PDF files, but this is the one we found most useful. Before demonstrating how to convert these grob-layouts to actual PDF files, let's create a couple:

```{r season summary, include=F}

season_summary_02_pt1 <- "The 2001-02 NBA season was the Kings' 53rd season in the National Basketball Association, and 17th season in Sacramento. During the offseason, the Kings acquired Mike Bibby from the Vancouver Grizzlies, and second-year guard Mateen Cleaves from the Detroit Pistons. Despite Chris Webber missing the first 20 games due to an ankle injury, the Kings posted a 12-game winning streak between December and January, as they held a 37-12 record before the All-Star break." 

season_summary_02_pt2 <- "The team won eleven straight games near the end of the season, finishing with a 61-21 record (.744 winning percentage), the best record in the league, while winning their division for the first time since 1979, when the team was in Kansas City. The Kings also made the Western Conference finals for the first time since 1981 (also as the Kansas City Kings). Webber and Peja Stojakovic were both selected for the 2002 NBA All-Star Game."

bench_bulleted_list <- paste0(
  'BE - Bobby Jackson\n',
  'BE - Hedo Turkoglu\n',
  'BE - Scott Pollard\n',
  'BE - Lawrence Funderburke\n',
  'BE - Gerald Wallace'
  )

```

```{r two page grob-layout}
# dummy text
pars <- unlist(strsplit(UsingR::lorem, "\n\n"))
first_paragraph <- pars[1]
second_paragraph <- pars[2]
sac_purple <- '#5A2D81'

first_page_gl <- grob_layout(
  grob_row(
    grob_col('kings_logo_old.png', p = 1/2),
    grob_col('adelman.png', title = 'COACH - Rick Adelman'),
    grob_col(
      p = 1/2,
      'Record : 61-21',
      aes_list = ga_list(
        n_lines = 1,
        font_face = 2,
        text_color = 'gray40'
        )
      )
    ),
  grob_row(
    title = 'BACK COURT',
    grob_col(NA, p = 1/2),
    grob_col('bibby.png', title = "PG - Mike Bibby"),
    grob_col('christie.png', title = 'SG - Doug Christie'),
    grob_col(NA, p = 1/2)
    ),
  grob_row(
    grob_col('stojakovic.png', title = 'SF - Peja Stojakovic'),
    grob_col('divac.png', title = 'C - Vlade Divac'),
    grob_col('webber.png', title = 'PF - Chris Webber'),
    title = 'FRONT COURT'),
  grob_row(
    p = 2/3,
    grob_col(
      season_summary_02_pt1,
      aes_list = ga_list(text_just = 'left'))),
  title = '2001-02 Sacramento Kings',
  title_aes_list = ga_list(background_color = sac_purple))

second_page_gl <- grob_layout(
  grob_row(
    grob_col(
      "",
      p = 1/4,
      aes_list = ga_list(
        round_rect_radius = 0.2,
        background_color = 'gray40')),
    grob_col('hedo.png', title = "BE - Hedo Turkoglu"),
    grob_col('kings_lion_logo.png')),
  grob_row(
    grob_col(
      bulleted_list,
      aes_list = ga_list(
        n_lines = 5,
        text_color = sac_purple,
        text_just = 'left')),
    grob_col(
      bench_bulleted_list,
      aes_list = ga_list(
        n_lines = 5,
        text_color = sac_purple,
        text_just = 'left')),
    grob_col(
      "",
      p = 1/4,
      aes_list = ga_list(
        round_rect_radius = 0.2,
        background_color = 'gray40'))),
  grob_row(
    p = 2/3,
    grob_col(
      season_summary_02_pt2,
      aes_list = ga_list(text_just = 'left'))),
  grob_row(
    grob_col(
      grob_row(p = 2, grob_col('webber.png')),
      grob_row(grob_col(
        'All-NBA, 2nd Team',
        aes_list = ga_list(
          n_lines = 1,
          round_rect_radius = 0.2,
          background_color = sac_purple,
          text_color = 'white')))),
    grob_col(
      grob_row(p = 2, grob_col('christie.png')),
      grob_row(grob_col(
        'All-Defense, 2nd Team',
        aes_list = ga_list(
          n_lines = 1,
          round_rect_radius = 0.2,
          background_color = sac_purple,
          text_color = 'white')))),
    title = "Season Accolades",
    border = T,
    border_aes_list = ga_list(border_width = 4, border_color = sac_purple))
)
```

Now that we have two grob-layout pages established, let's put them together into a single PDF document with `grob_to_pdf()`! With the `grob_to_pdf()` function, the user has to provide a `file_name` for the PDF output, and whether to add a page number to each of the grob-layouts in their bottom-right corners. Only the objects outputted by `grob_layout()` can be inserted into `grob_to_pdf()`, either loose or contained in a single list:

```{r Grob to PDF, eval=F}
# grob_to_pdf(
#   first_page_gl,
#   second_page_gl,
#   file_name = 'grobblR_vignette',
#   add_page_numbers = T)

# OR

grob_to_pdf(
  list(first_page_gl, second_page_gl),
  file_name = 'grobblR_vignette',
  add_page_numbers = T)
```

The saved PDF can be found [here](https://github.com/calvinmfloyd/grobblR/blob/master/vignettes/grobblR_vignette.pdf).

***
